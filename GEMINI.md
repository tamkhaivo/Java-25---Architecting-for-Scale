# Gemini Code Generation Configuration for Java 25

This document outlines the coding styles, conventions, and architectural paradigms to be followed for the "Java 25 - Architecting for Scale" project. The purpose of this guide is to ensure that all code generated by Gemini or written by developers is consistent, readable, and adheres to modern best practices.

## 1. Core Principles

*   **Immutability:** Strive for immutability whenever possible. Use `final` for variables, fields, and collections that should not be modified after initialization. Prefer immutable objects and classes.
*   **Avoid Nulls:** Actively avoid `null` references. Utilize `java.util.Optional` to represent optional values explicitly. Code should be written to handle `Optional` gracefully.
*   **Single Responsibility Principle (SRP):** Each class and method should have one, and only one, reason to change. Keep components small and focused.
*   **Dependency Inversion Principle (DIP):** Depend on abstractions, not on concrete implementations. Use interfaces to define contracts between different parts of the system.

## 2. Naming Conventions

*   **Packages:** Lowercase, using reverse domain name notation (e.g., `com.example.project.module`).
*   **Classes and Interfaces:** UpperCamelCase (e.g., `UserService`, `OrderRepository`).
*   **Enums:** UpperCamelCase for the enum type, and UPPER_SNAKE_CASE for enum constants (e.g., `OrderStatus.PENDING`).
*   **Methods:** lowerCamelCase (e.g., `calculateTotal`, `getUserById`).
*   **Variables:** lowerCamelCase (e.g., `orderCount`, `userName`).
*   **Constants:** `static final` fields should be in UPPER_SNAKE_CASE (e.g., `MAX_RETRIES`).
*   **Test Classes:** The name of the test class should correspond to the class it tests, with a `Test` suffix (e.g., `UserServiceTest`).

## 3. Formatting and Style

*   **Indentation:** Use 4 spaces for indentation, not tabs.
*   **Brace Style:** Use the Allman style for braces (braces on a new line).

    ```java
    class MyClass
    {
        void myMethod()
        {
            if (condition)
            {
                // ...
            }
        }
    }
    ```
*   **Line Length:** Keep lines under 120 characters to improve readability.
*   **Imports:**
    *   Avoid wildcard imports (e.g., `java.util.*`).
    *   Organize imports in the following order: `java`, `javax`, `org`, `com`, static imports.

## 4. Modern Java (Java 25+)

Leverage modern Java features to write more concise and expressive code.

*   **Records:** Use `record` for plain data carriers (DTOs, entities).
*   **Pattern Matching:** Use pattern matching for `instanceof`.
*   **Switch Expressions:** Prefer switch expressions over switch statements.
*   **Sealed Classes/Interfaces:** Use `sealed` to control implementation hierarchies.
*   **Virtual Threads (Project Loom):** This is the default concurrency model for all I/O-bound tasks. See Architectural Decisions below.

## 5. Architectural Paradigms & Decisions

### 5.1 Event-Driven Architecture (EDA)
**Mandate:** All inter-service communication MUST be asynchronous and event-driven, implemented via a central message broker (e.g., Kafka, RabbitMQ). Direct synchronous calls (e.g., REST, gRPC) between microservices are prohibited to ensure maximum decoupling and scalability.

*   **Rationale:** This approach prioritizes system throughput, resilience, and evolvability. Services remain isolated, can be scaled independently, and can evolve without breaking downstream consumers.
*   **Event Design:**
    *   **Immutability:** Events are records of something that happened in the past and MUST be immutable.
    *   **Schema Definition:** All events MUST have a clearly defined, versioned schema (e.g., using Avro, Protobuf, or JSON Schema).
    *   **Naming:** Event names should be in the past tense (e.g., `OrderPlaced`, `UserRegistered`).
*   **Idempotent Consumers:** Service consumers MUST be designed to be idempotent. Due to "at-least-once" delivery semantics, a consumer might receive the same event multiple times and must produce the same result without side effects.

### 5.2 Cloud-Native
Design applications to be cloud-native. This includes principles from the 12-Factor App methodology, such as externalized configuration and stateless processes.

### 5.3 Virtual Thread Concurrency Model
**Mandate:** Virtual threads are the default and required model for handling all I/O-bound and concurrent tasks. This includes message queue consumption, database access, and any other network calls. The goal is to maximize throughput by using simple, blocking code.

*   **Rationale:** This model provides massive scalability for I/O-heavy workloads with a much simpler programming model than traditional asynchronous or reactive approaches.

*   **Pinning Avoidance Strategy:** To ensure virtual threads yield as expected, the following rules MUST be followed:
    *   **Avoid `synchronized`:** Do not use `synchronized` blocks or methods in application code. For concurrency control, use `java.util.concurrent.locks.ReentrantLock` instead.
    *   **Vet Dependencies:** Before adding a new dependency, verify that it is virtual-thread-safe. Give preference to libraries and database drivers that have been explicitly updated for Project Loom.
    *   **Monitor Pinning:** During development and testing, regularly run the application with the `-Djdk.tracePinnedThreads=full` JVM option. Analyze the stack traces to identify and remediate any code that causes pinning.

### 5.4 Resiliency Patterns

**Mandate:** All microservices MUST incorporate appropriate resiliency patterns to prevent cascading failures and ensure graceful degradation. The implementation of these patterns is the responsibility of individual teams, who should select the most suitable tools and libraries for their specific service, provided they adhere to the principles outlined below.

*   **Rationale:** In a distributed, event-driven architecture, services must be designed to withstand failures of their dependencies and operate reliably under adverse conditions.
*   **Mandatory Patterns:**
    *   **Circuit Breaker:** MUST be implemented for all external service calls (e.g., database, other microservices, external APIs). A circuit breaker should trip after a configured threshold of failures, preventing further calls to a failing dependency and allowing it time to recover.
    *   **Retry:** SHOULD be implemented for transient failures in external service calls. Retries should use exponential backoff and have a maximum number of attempts to avoid overwhelming the dependency.
    *   **Bulkhead:** SHOULD be used to isolate components or resources to prevent a failure in one area from consuming all resources and affecting other parts of the service.
*   **Implementation Guidance:**
    *   Teams are encouraged to choose robust, well-maintained libraries (e.g., Resilience4j, Hystrix alternatives) for pattern implementation.
    *   Configuration for these patterns (e.g., failure thresholds, retry delays, timeout values) MUST be externalized and configurable at runtime.
    *   Monitoring and alerting MUST be in place for all implemented resiliency patterns to track their state (e.g., circuit open/closed, number of retries) and performance.

## 6. Testing

*   **Unit Tests:** Every class should have corresponding unit tests. Use a mocking framework like Mockito where appropriate.
*   **Integration Tests:** Write integration tests for components that interact with external systems (databases, other services). Use libraries like Testcontainers to manage external dependencies in tests.
*   **Assertion Library:** Use a rich assertion library like AssertJ for more readable and expressive test assertions.

## 7. Dependencies

*   **Build Tool:** Use Maven or Gradle for dependency management.
*   **Dependency Injection:** Use a dependency injection framework like Spring or Guice to manage object creation and wiring.
*   **Minimize Dependencies:** Be cautious about adding new dependencies. Prefer well-maintained, popular libraries.
